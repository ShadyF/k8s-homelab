# TODO: Figure out why people add resource limits here
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: ingress-nginx
  namespace: networking
spec:
  interval: 5m
  chart:
    spec:
      # renovate: registryUrl=https://kubernetes.github.io/ingress-nginx
      chart: ingress-nginx
      version: 3.34.0
      sourceRef:
        kind: HelmRepository
        name: ingress-nginx-charts
        namespace: flux-system
      interval: 5m
  values:
    controller:
      replicaCount: 1
      service:
        type: LoadBalancer
        loadBalancerIP: 192.168.1.240
        # See https://docs.microsoft.com/en-us/azure/aks/concepts-network#client-source-ip-preservation
        # Also see https://metallb.universe.tf/usage/#traffic-policies for what happens when used
        # in conjuction with MetalLB
        externalTrafficPolicy: Cluster
      config:
        ssl-protocols: "TLSv1.3 TLSv1.2"
        # Same size defined in cloudflare
        proxy-body-size: "100m"
        # Helps with getting real IP, I think?
        use-forwarded-headers: "true"
        log-format-escape-json: "true"
        log-format-upstream: '{'
                               '"msec": "$msec", ' # request unixtime in seconds with a milliseconds resolution
                               '"connection": "$connection", ' # connection serial number
                               '"connection_requests": "$connection_requests", ' # number of requests made in connection
                               '"pid": "$pid", ' # process pid
                               '"request_id": "$request_id", ' # the unique request id
                               '"request_length": "$request_length", ' # request length (including headers and body)
                               '"remote_addr": "$remote_addr", ' # client IP
                               '"remote_user": "$remote_user", ' # client HTTP username
                               '"remote_port": "$remote_port", ' # client port
                               '"time_local": "$time_local", '
                               '"time_iso8601": "$time_iso8601", ' # local time in the ISO 8601 standard format
                               '"request": "$request", ' # full path no arguments if the request
                               '"request_uri": "$request_uri", ' # full path and arguments if the request
                               '"args": "$args", ' # args
                               '"status": "$status", ' # response status code
                               '"body_bytes_sent": "$body_bytes_sent", ' # the number of body bytes exclude headers sent to a client
                               '"bytes_sent": "$bytes_sent", ' # the number of bytes sent to a client
                               '"http_referer": "$http_referer", ' # HTTP referer
                               '"http_user_agent": "$http_user_agent", ' # user agent
                               '"http_x_forwarded_for": "$http_x_forwarded_for", ' # http_x_forwarded_for
                               '"http_host": "$http_host", ' # the request Host: header
                               '"server_name": "$server_name", ' # the name of the vhost serving the request
                               '"request_time": "$request_time", ' # request processing time in seconds with msec resolution
                               '"upstream": "$upstream_addr", ' # upstream backend server for proxied requests
                               '"upstream_connect_time": "$upstream_connect_time", ' # upstream handshake time incl. TLS
                               '"upstream_header_time": "$upstream_header_time", ' # time spent receiving upstream headers
                               '"upstream_response_time": "$upstream_response_time", ' # time spend receiving upstream body
                               '"upstream_response_length": "$upstream_response_length", ' # upstream response length
                               '"upstream_cache_status": "$upstream_cache_status", ' # cache HIT/MISS where applicable
                               '"ssl_protocol": "$ssl_protocol", ' # TLS protocol
                               '"ssl_cipher": "$ssl_cipher", ' # TLS cipher
                               '"scheme": "$scheme", ' # http or https
                               '"request_method": "$request_method", ' # request method
                               '"server_protocol": "$server_protocol", ' # request protocol, like HTTP/1.1 or HTTP/2.0
                               '"pipe": "$pipe", ' # "p" if request was pipelined, "." otherwise
                               '"gzip_ratio": "$gzip_ratio", '
                               '"http_cf_ray": "$http_cf_ray",'
                               '"geoip_country_code": "$geoip_country_code"'
                               '}'
      # Enable when grafana / prometheus is added
      metrics:
        enabled: false
        serviceMonitor:
          enabled: false
      # Wildcare certificate so we don't have to define a certificate for each ingress we create
      extraArgs:
        default-ssl-certificate: "networking/${SECRET_DOMAIN/./-}-tls"
