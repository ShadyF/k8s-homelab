# TODO: Figure out why people add resource limits here
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: ingress-nginx
  namespace: networking
spec:
  interval: 5m
  chart:
    spec:
      # renovate: registryUrl=https://kubernetes.github.io/ingress-nginx
      chart: ingress-nginx
      version: 4.2.1
      sourceRef:
        kind: HelmRepository
        name: ingress-nginx-charts
        namespace: flux-system
      interval: 5m
  values:
    controller:
      replicaCount: 1
      service:
        type: LoadBalancer
        loadBalancerIP: 192.168.1.240
        # See https://docs.microsoft.com/en-us/azure/aks/concepts-network#client-source-ip-preservation
        # Also see https://metallb.universe.tf/usage/#traffic-policies for what happens when used
        # in conjuction with MetalLB
        externalTrafficPolicy: Local
      config:
        ssl-protocols: "TLSv1.3 TLSv1.2"
        # Same size defined in cloudflare
        proxy-body-size: "100m"
        # Helps with getting real IP, I think?
        use-forwarded-headers: "true"
        log-format-escape-json: "true"
        log-format-upstream: '{
          "msec": "$msec",
          "connection": "$connection",
          "connection_requests": "$connection_requests",
          "pid": "$pid",
          "request_id": "$request_id",
          "request_length": "$request_length",
          "remote_addr": "$remote_addr",
          "remote_user": "$remote_user",
          "remote_port": "$remote_port",
          "time_local": "$time_local",
          "time_iso8601": "$time_iso8601",
          "request": "$request",
          "request_uri": "$request_uri",
          "args": "$args",
          "status": "$status",
          "body_bytes_sent": "$body_bytes_sent",
          "bytes_sent": "$bytes_sent",
          "http_referer": "$http_referer",
          "http_user_agent": "$http_user_agent",
          "http_x_forwarded_for": "$http_x_forwarded_for",
          "http_host": "$http_host",
          "server_name": "$server_name",
          "request_time": "$request_time",
          "upstream": "$upstream_addr",
          "upstream_connect_time": "$upstream_connect_time",
          "upstream_header_time": "$upstream_header_time",
          "upstream_response_time": "$upstream_response_time",
          "upstream_response_length": "$upstream_response_length",
          "upstream_cache_status": "$upstream_cache_status",
          "ssl_protocol": "$ssl_protocol",
          "ssl_cipher": "$ssl_cipher",
          "scheme": "$scheme",
          "request_method": "$request_method",
          "server_protocol": "$server_protocol",
          "pipe": "$pipe",
          "gzip_ratio": "$gzip_ratio",
          "http_cf_ray": "$http_cf_ray",
          "geoip_country_code": "$geoip_country_code"
        }'
      # Enable when grafana / prometheus is added
      metrics:
        enabled: false
        serviceMonitor:
          enabled: false
      # Wildcare certificate so we don't have to define a certificate for each ingress we create
      extraArgs:
        default-ssl-certificate: "networking/${SECRET_DOMAIN/./-}-tls"
